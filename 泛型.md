1.泛型

<!-- type ISwap = <T, K>(tuple: [T, K]) => [K, T];
     let swap: ISwap = (tuple) => {
       return [tuple[1], tuple[0]];
     };
     let r = swap(["abc", 123]);
-->

<!--
    type ICallback<T> = (item: T, index: number) => void;
    //表示使用类型的时候传参
    type IForEach = <T>(arr: T[], callback: ICallback<T>) => void;
    //表示调用函数的时候传参

    const forEach: IForEach = (arr, callback) => {
        for (let index = 0; index < arr.length; index++) {
            callback(arr[index], index);
        }
    };

    forEach([1, 2, 3, "a", "b", "c"], function (item, index) {});
 -->

泛型默认值
type Union<T = boolean> = T | number | string
泛型约束
要求传递的参数必须符合要求,A extends B 要求:A 是 B 的子类型或者同类型
//对于对象而言，儿子的类型结构是比父亲多的(就相当于儿子继承父亲)

 <!-- 
    interface IWithLen {
        length: number;
    } 
    interface T extends IWithLen {
       a: number;
       b: number;
    }

-->
<!--
    interface IWithLen {
        length: number;
    }
    function handle<T extends IWithLen>(val: T) {
        return val.length;
    }
    handle({ a: 1, b: 2, length: 123 });
-->

开发中通过泛型坑位，来占位置

2.交叉类型
|并集
&交集

let a1: string | number;
a1 = "1";
a1 = 1

<!-- interface Person1 {
        handsome: string;
     }
    interface Person2 {
        high: string;
    }
    type Person3 = Person1 & Person2;
    let person3: Person3 = {
       handsome: "帅",
       high: "高",
    };
-->

3.unknown 是 any 的安全类型，泛型没有赋值的时候，默认就是 unknown,unknown 必须先要进行类型检测才能使用（类型检查、类型断言）
type UnionUnknown = unknown | string | null ===> unknown //unknown 和任何类型做联合类型都是 unknown
type InternUnknown = unknown & string ===> string
type InternAny = any & string ===> any
type IKeyOf = keyof any ===>  string | number | symbol
type IKeyOf = keyof unknown ===> never